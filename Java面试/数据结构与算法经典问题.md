# 数据结构与算法经典问题解析

### 数组

> 整个数组所有的元素都存储在操作系统分配的一个内存中。
> 通过使用特定元素的索引作为数组下标，可以常数时间内访问数组元素。

1. 为什么能在 常数时间内访问数组元素
2. 数组的优点：访问元素快
3. 数组的缺点
   - 大小固定
   - 分配一个连续的空间块
   - 基于位置的插入操作实现复杂
4. 动态数组
5. 链表的优点
   - 初始时仅需分配一个元素的存储空间
   - 添加新元素很容易
6. 链表的缺点
   - 访问单个元素的时间开销
   - 链表中的额外指针引用需要浪费内存

### 单向链表

1. 遍历

2. 插入

3. 在开头插入结点

4. 在结尾插入结点

5. 在中间插入结点

6. 删除

7. 删除第一个结点

8. 删除最后一个结点

9. 删除中间的一个结点

10. 删除整个表（释放每一个结点空间）

    ```java
    void deleteLinkedList(ListNode head){
            ListNode auxilaryNode;
            ListNode iterator = head;
            while(iterator != null){
                auxilaryNode = iterator.getNext();
                iterator = null;
                iterator = auxilaryNode;
            }
        }
    ```


### 双向链表

> 优点：对于链表中一个给定的结点，可以从两个方向进行操作。每个节点都有一个指向前驱结点的的指针，可以直接后退到前驱结点。
> 缺点：每个结点都需要再添加一个额外的指针，因此需要更多的空间开销。插入和删除需要更多的指针操作。

### 栈

> 栈是一个有序线性表，只能在表的一端执行插入和删除操作。后进先出。

1. 应用

   - 符号匹配
   - 中缀表达式改为后缀表达式
   - 计算后缀表达式
   - 实现函数调用
   - 求范围误差
   - 网页浏览器后退历史记录
   - 文本编辑器撤销操作
   - HTML和XML文件中tag匹配

2. 简单数组实现

3. 动态数组实现

   > 倍增太多可能导致内存溢出

4. 链表实现

5. 各种实现比较

   - 递增策略和倍增策略比较

     各个操作都是常数时间开销

     每隔一段时间倍增操作的开销较大

     n个操作的任意序列的平摊时间开销为O(n)

   - 基于数组实现和基于链表实现

     栈规模的增加和减小都很简洁

     各个操作都是常数时间开销

     每个操作都要使用额外的空间和时间开销来处理指针

###  队列

> 队列是一种只能在一端插入，另一端删除的有序线性表。队列中第一个插入的元素也是第一个被删除的元素。先进先出。

1. 应用
   - 操作系统根据任务到达的顺序调度任务
   - 模拟现实世界中的队列
   - 多道程序设计
   - 异步数据传输
   - 客户在呼叫中心的等待时间
   - 确定超市收银员的数量
2. 实现
   - 基于简单循环数组实现队列
   - 基于动态循环数组实现队列
   - 基于链表实现队列

### 树

> 树的一个结点可以指向多个结点

1. 术语
   - 根结点
   - 边
   - 叶子结点
   - 兄弟结点
   - 祖先结点
   - 结点大小
   - 树的层
   - 结点的深度：从根结点到该结点的路径长度
   - 结点的高度：从该结点到最深结点的路径长度
   - 树的高度
   - 斜树
2. 二叉树
3. 二叉树应用
   - 编译器中的表达式树
   - 用于数据压缩算法中的赫夫曼编码树
   - 支持在集合中查找、插入和删除，其平均时间复杂度为O(logn)的二叉搜索树
   - 优先队列，它支持以对数时间对集合中的最小数据元素进行搜索和删除
4. 二叉树的遍历方式
   - LDR
   - LRD
   - DLR
   - DRL
   - RDL
   - RLD
5. 遍历的分类
   -  前序遍历
   - 中序遍历
   - 后序遍历
   - 层次遍历