# 基于数据的分割实现并发化

##### 基本思想

将原始输入数据按照一定的规则（比如均分）分解为若干规模较小的子输入（数据），并使用工作者线程来对这些子输入进行处理，从而实现对输入数据的并发处理。对子输入的处理，我们称之为子任务。因此，基于数据分割的结果使产生一批子任务，这些子任务由专门的工作者线程负责执行。

##### 启发

基于数据分割的这种并发化程序处理的数据角度入手，将原始输入分解为若干规模更小的子输入，并将这些子输入指派给专门的工作者线程处理。基于数据分割的结果是产生多个同质工作者线程，即任务处理逻辑相同的线程。

细节

- 工作者线程数量的合理设置问题。线程数量的增加也会导致其他开销（比如上下文切换）增加。
- 工作者线程的异常处理问题。一个下载线程执行过程中出现异常的时候，这个线程是可以进行重试呢，还是说直接就算整个资源的下载失败呢？
- 原始输入规模未知问题。对于原始输入规模事先不可知的问题，我们可以采用批处理的方式对原始输入进行分解：聚集好一批数据之后再将这些数据指派给工作者线程进行处理。
- 程序的复杂性增加的问题。数据段并发地从服务器上下载，最终需要得到一个完整的大文件，而不是几个较小的文件。一种方法是合并，另一种方法是写入同一个文件（容易增加I/O的次数，于是采用缓存方法）

##### 实战案例

- 基于多线程的大文件下载器

  一个大小未600MB的文件在网络宽带为100Mbps的情况下，使用单个线程下载，至少需要耗时48（=600/（100/8））秒，若以3个线程来下载该文件，每个线程分别下载该文件的一部分，那么下载这个文件所需要的时间基本上可以减少为16（600/3/（100/8））秒。

# 基于任务的分割实现并发化

##### 基本思想

将任务按照一定的规则分解成若干子任务，并使用专门的工作者线程去执行这些子任务，从而实现任务的并发执行，按照原始任务的分解方式来划分，基于任务的分解可以分为按任务的资源消耗属性分割和按处理步骤分割这两种。

按任务的资源消耗属性分割

- CPU密集型任务
- I/O密集型任务

类似地，一个线程所执行的任务实际上往往同时兼具CPU密集型任务和I/O密集型任务特征，称之为混合型任务。我们可能需要将这种混合型任务进一步分解为CPU密集型和I/O密集型这两种任务 ，并使用专门的工作者线程负责这些子任务的执行，以提高并发性。

##### 启发

基于任务的分割这种并发化策略是从程序的处理逻辑角度入手，将原始任务处理逻辑分解为若干子任务，并创建专门的工作者线程来执行这些子任务。

基于任务的分割结果是产生多个相互协作的**异质工作者线程**，即任务处理逻辑各异的线程。

##### 实战案例

某分布式电信系统需要一款统计工具，用于从指定的接口日志文件中统计出外部系统处理指定请求的响应延时情况。

文件格式：

操作时间戳（UTC时间）| 协议类型（SOAP/REST/HTTP）| 记录类型（请求/响应）| 接口名称 | 操作名称 | 原设备名 | 目标设备名 | 消息唯一标识（traceId）| 本机IP地址 | 主叫号码 | 被叫号码

