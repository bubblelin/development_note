 ### 新I/O
 Java I/O 速度的提高来自与使用的结构更接近于操作系统执行I/O的方式：通道和缓存。

 旧I/O类库中有三个类被修改了，用以产生 FileChannel。这三个被修改的类是 FileInputStream、FileOutputStream 以及用来即读又写的 RandomAccessFile。

 将字节存放在 ByteBuffer 的方法之一是：使用 put() 方法直接对其进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用 warp() 方法将已存在的字节数组包装到 ByteBuffer 中。一旦如此，就不在赋值底层的数组，而是把它作为所产生的的 ByteBuffer 的存储器，称之为数组支持的 ByteBuffer。

#### 通道和缓冲区

概述

通道和缓冲区是NIO中核心对象，几乎每一个I/O操作中都要使用它们。通道是对原I/O包中的流的模拟。到任何目的地的所有数据都必须通过一个Channel对象。一个Buffer实质上是一个容器对象，发送给一个通道的所有对象都必须首先放到缓冲区中；同样，从通道中读取的任何数据都要读到缓冲区中。

通道

Channel是一个对象，可以通过它读取和写入数据。拿NIO与原来的I/O做个比较，通道就像是流。

所有数据通过Buffer对象来处理，您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。

缓冲区

Buffer是一个对象，它包含一些要写入或者读出的数据。在NIO中加入Buffer对象，体现了新库与原I/O的一个重要区别。（在面向流的I/O中，您将数据直接写入或者直接读到Stream对象中。）在NIO库中，所有数据都是用缓冲区处理的，在读取数据时，它是直接读到缓冲去中，在写入数据时，它是写入到缓冲区中的。任何时候访问NIO中的数据，都是将它放到缓冲区中。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 *仅仅* 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

clear()方法重设缓冲区，使它可以接受读入的数据。flip()方法让缓冲区可以将新读入的数据写入另一个通道。

 #### 字节存放书讯

不同的机器可能采用不同的字节排序方式来存放数据。
- “big endian” 高位优先将最重要的字节存放在地址最低的存储单元。
- “little endian” 低位优先则是将最重要的字节存放在地址最高的存放单元。当存储了大于一个字节时，像 int、float 等，就要考虑字节的顺序问题了。
- ByteBuffer 是以高位优先的形式存储数据的，数据在网上传送时也常常采用高位优先的形式。我们可以使用带参数的 ByteOrder.BIG_ENDIAN 或 ByteOrder.LITTLE_ENDIAN 的 order() 方法改变 ByteBuffer 的字节排序方式。


#### 缓冲器细节

Buffer 由数据和可以高效的访问以及操作这些数据的四个索引组成，这四个索引是：
- mark (标记)
- position (位置)
- limit (界限)
- capacity (容量)

position 最大可以为capacity-1，当将Buffer从写模式切换到读模式，position会重置为0