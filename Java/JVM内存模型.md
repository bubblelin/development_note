### Java内存区域

Java 虚拟机的内存区域分为五部分, 分别是:

1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区



- #### 程序计数器

程序计数器是一块较小的内存空间,可以看作**当前线程正在执行的字节码的行号指示器**. 也就是, 程序计数区里面记录的是当前线程正在执行的那一条字节码指令的地址.
注: 如果当前线程正在执行的是一个本地方法, 那么此时程序计数器为空.

程序计数器的作用:

1. 字节码解释器通过改变程序计数器来依次读取指令,从而实现代码的流程控制,如: 顺序执行、选择、循环、异常处理；
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

程序计数器的特点：

1. 是一块较小的存储空间；
2. 线程私有。每条线程都有一个程序计数器；
3. 是唯一一个不会出现 OutOfMenmoryError的内存区域；
4. 生命周期随着线程的创建而创建，随着线程的结束而死亡。



- #### Java 虚拟机栈（帧栈）

Java 虚拟机栈是描述Java方法运行过程的内存模型。
Java 虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域。这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：

1. 局部变量表：
       存放基本数据类型变量、引用类型的变量、returnAddress类型的变量；
2. 操作数栈；
3. 动态链接；
4. 方法出口信息等。

当一个方法即将被运行时， Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包括局部变量表、操作数栈、动态链接、方法出口信息等。

当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。

当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。

注意：人们常说的Java内存空间分为“栈“和“堆“，栈中存放局部变量，堆中存放对象。这句话不完全正确！

这里的“堆”可以这么理解， 但这里的“栈”只代表了Java虚拟机栈中的局部变量部分。真正的Java虚拟机栈是一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

Java 虚拟机栈的特点：

1. 局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。
       而且，局部变量表的大小在编译时期就确定下来了， 在创建的时候只需要事先分配好先规定的大小即可。
       此外，在方法运行的过程中局部变量表的大小是不会发成改变的。

2. Java 虚拟机栈会出现两种异常：

   StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就会抛出异常；

    OutOfMemoryError：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出该异常。

3. Java 虚拟机栈也是线程私有的， 每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。



- #### 本地方法栈

本地方法栈和Java 虚拟级机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间。也会抛出StackOverFlowError和OutOfMemoryError异

常。



- #### 堆

堆是用来存放对象的内存空间。几乎所有的对象都存储在堆中。

堆的特点：

1. 线程共享：
       整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个。
2. 在虚拟机启动时创建；
3. 垃圾回收的主要场所；
4. 可以进一步细分为：新生代、老年代；
       新生代又可以分为Eden、From Survior、To Survior。
       不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的来及回收算法，从而更具有针对性，从而更高效。
5. 堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再拓展时，就跑出OutOfMemoryError。



- #### 方法区


- 类信息
- 常量
- 静态变量
- 即时编译后的代码
- ...

Java 虚拟机规范中定义方法区是堆的一个逻辑部分。
方法区存放已经被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。

方法区的特点：

1. 线程共享。
       

   方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。

2. 永久代。
       

   方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。

3. 内存回收效率低。
       

   方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。
       

   对方法区的内存回收的主要目标是：对常量池的回收和对类型的卸载。

4. Java 虚拟机规范对方法区的要求比较宽松。

    和堆一样，允许固定大小，也允许可拓展的大小，还允许不实现垃圾回收

运行时常量：
方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。
我们一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成 .class文件，这个类的所有信息都存储在这个 .class文件中。
当这个类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。
如：String类的intern（）方法就能在运行期间向常量池中添加字符串常量。
当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。



- 
  #### 直接内存

直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。
在NIO中引入了一种基于通道和缓冲的IO方式。
它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。

直接内存的大小不受Java虚拟机控制，既然是内存，当内存不足时会跑出OOM异常。



## 综上所述
Java 虚拟机的内存模型中一共有两个 “栈”，分别是：Java 虚拟机栈和本地方法栈。
两个 “栈” 的功能类似，都是方法运行过程的内存模型。并且两个 “栈” 内部构造相同，都是线程私有。

只不过 Java 虚拟机栈描述的是 Java 方法运行过程的内存模型，而本地方法栈是描述 Java 本地方法运行过程的内存模型。

Java 虚拟机的内存模型中一共有两个 “堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。

堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。堆是 Java 虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。

程序计数器、Java 虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java 虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。

而堆、方法区是线程共享的，在 Java 虚拟机中只有一个堆、一个方法栈。并在 JVM 启动的时候就创建，JVM 停止才销毁。


### JVM内存配置
eclipse启动的时候：

VM arguments: 

-verbose:gc 

-Xms20M 

-Xmx20M 

-Xmn10M 

-XX:+PrintGCDetails 

-XX:SurvivorRatio=8

代码通过Runtime类获取内存信息。



### Java内存模型和Java内存区域

Java内存模型和Java内存区域的划分是不同的概念层次：

Java内存模型描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式。

Java内存模型围绕原子性、有序性、可见性展开。

Java内存模型和Java内存区域唯一相似点，都存在共享数据区域和私有数据区域。

### 

### JVM 内存模型

###### 概述

Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括**实例字段**，**静态字段**和**构成数组对象的元素**）的访问方式。

JVM运行程序的实体是**线程**，而每个线程创建时JVM都会为其创建一个工作内存或叫栈空间，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行：

> 首先将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成后再将变量写回主内存；
>
> 不能直接操作主内存中的变量；
>
> 工作内存中存储着主内存中的变量副本拷贝；
>
> 工作内存是每个线程私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过主内存。

主内存：

主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。

工作内存：

主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。







